---
phase: 02-professional-metadata
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/services/authority.ts
  - src/utils/display.ts
autonomous: true

must_haves:
  truths:
    - "User can view all three authority types (mint, freeze, metadata update)"
    - "User can optionally revoke metadata update authority"
    - "Authority revocation shows irreversibility warning"
  artifacts:
    - path: "src/services/authority.ts"
      provides: "Authority status checking and revocation"
      exports: ["getAuthorityStatus", "revokeMetadataAuthority", "AuthorityStatus"]
    - path: "src/utils/display.ts"
      provides: "Authority dashboard display"
      exports: ["displayAuthorityDashboard"]
  key_links:
    - from: "src/services/authority.ts"
      to: "@solana/spl-token getMint"
      via: "check mint/freeze authority"
      pattern: "getMint.*mintAuthority"
    - from: "src/services/authority.ts"
      to: "@metaplex-foundation/mpl-token-metadata"
      via: "check metadata isMutable field"
      pattern: "fetchMetadataFromSeeds.*isMutable"
---

<objective>
Create authority management service with status dashboard and optional metadata authority revocation.

Purpose: Users need visibility into which authorities are active vs revoked to understand their token's security posture. Metadata update authority is a third authority type (beyond mint/freeze from Phase 1) that controls whether name/symbol can be changed.

Output: Service that checks all three authority types and can optionally revoke metadata update authority.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output
@.planning/phases/02-professional-metadata/02-01-SUMMARY.md

# Research
@.planning/phases/02-professional-metadata/02-RESEARCH.md

# Existing code
@src/lib/token.ts
@src/utils/display.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create authority status service</name>
  <files>src/services/authority.ts</files>
  <action>
Create `src/services/authority.ts` with:

1. **AuthorityStatus interface:**
```typescript
export interface AuthorityStatus {
  mint: {
    authority: string | null;  // null = revoked
    isRevoked: boolean;
    yours: boolean;  // true if authority matches payer
  };
  freeze: {
    authority: string | null;
    isRevoked: boolean;
    yours: boolean;
  };
  metadataUpdate: {
    authority: string | null;
    isMutable: boolean;  // false = metadata is immutable (authority revoked)
    yours: boolean;
  };
}
```

2. **getAuthorityStatus function:**
```typescript
export async function getAuthorityStatus(
  connection: Connection,
  mint: PublicKey,
  payer: PublicKey
): Promise<AuthorityStatus>
```

Implementation:
a. Get mint info using `getMint(connection, mint)` from @solana/spl-token
b. Check mintAuthority and freezeAuthority from mint info
c. Get metadata account using Umi's fetchMetadataFromSeeds:
```typescript
import { createUmi } from '@metaplex-foundation/umi-bundle-defaults';
import { fetchMetadataFromSeeds, mplTokenMetadata } from '@metaplex-foundation/mpl-token-metadata';
import { publicKey } from '@metaplex-foundation/umi';

const umi = createUmi(connection.rpcEndpoint).use(mplTokenMetadata());
const metadata = await fetchMetadataFromSeeds(umi, { mint: publicKey(mint.toBase58()) });
```
d. Check metadata.isMutable field (false = update authority revoked)
e. Check metadata.updateAuthority
f. Return AuthorityStatus object comparing against payer's public key

Handle case where metadata account doesn't exist (token created before Phase 2 without metadata).

3. **revokeMetadataAuthority function:**
```typescript
export async function revokeMetadataAuthority(
  connection: Connection,
  payer: Keypair,
  mint: PublicKey
): Promise<string>  // Returns transaction signature
```

Implementation:
Use Umi's updateV1 to set isMutable = false:
```typescript
import { updateV1 } from '@metaplex-foundation/mpl-token-metadata';

const tx = await updateV1(umi, {
  mint: publicKey(mint.toBase58()),
  authority: umi.identity,
  isMutable: false,  // This makes metadata immutable
}).sendAndConfirm(umi);
```

**Important:** This is IRREVERSIBLE. The function should NOT include any warnings - that's the CLI's job. This is pure service logic.

Return transaction signature for confirmation.
  </action>
  <verify>
`npm run build` succeeds
`src/services/authority.ts` exports getAuthorityStatus, revokeMetadataAuthority, AuthorityStatus
  </verify>
  <done>Authority service can check all three authority types and revoke metadata update authority</done>
</task>

<task type="auto">
  <name>Task 2: Add authority dashboard display</name>
  <files>src/utils/display.ts</files>
  <action>
Add to `src/utils/display.ts`:

1. **Import AuthorityStatus** from authority service

2. **displayAuthorityDashboard function:**
```typescript
export function displayAuthorityDashboard(status: AuthorityStatus): void
```

Display format (using existing chalk patterns):
```
Token Authority Dashboard

  Mint Authority:
    Status:      REVOKED (supply is fixed)
    Security:    Cannot mint additional tokens

  Freeze Authority:
    Status:      REVOKED (no honeypot risk)
    Security:    Token accounts cannot be frozen

  Metadata Update Authority:
    Status:      ACTIVE (yours)
    Security:    Name/symbol can still be changed
    Note:        Run with --lock-metadata to make immutable
```

For each authority:
- Show REVOKED in green or ACTIVE in yellow
- If ACTIVE and "yours" = true, show "(yours)" indicator
- If ACTIVE and not yours, show the public key (truncated: first 4...last 4)
- Include educational note about what each authority controls
- For metadata update, show note about --lock-metadata option if still active

Use existing chalk patterns from display.ts (cyan for headers, gray for labels, green/yellow for status).
  </action>
  <verify>
`npm run build` succeeds
`displayAuthorityDashboard` exported from display.ts
  </verify>
  <done>Authority dashboard displays all three authority types with security implications and educational notes</done>
</task>

</tasks>

<verification>
After tasks complete:
1. `npm run build` - compiles without errors
2. authority.ts exports getAuthorityStatus and revokeMetadataAuthority
3. display.ts exports displayAuthorityDashboard
4. AuthorityStatus includes mint, freeze, and metadataUpdate fields
</verification>

<success_criteria>
- getAuthorityStatus checks all three authority types
- Metadata authority check uses Umi fetchMetadataFromSeeds
- revokeMetadataAuthority uses updateV1 with isMutable=false
- Dashboard displays clear status with security implications
- Active authorities show ownership indicator (yours vs other address)
- Educational notes explain what each authority controls
- Follows existing display patterns (chalk colors, formatting)
</success_criteria>

<output>
After completion, create `.planning/phases/02-professional-metadata/02-03-SUMMARY.md`
</output>
