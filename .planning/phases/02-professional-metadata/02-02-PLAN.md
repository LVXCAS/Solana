---
phase: 02-professional-metadata
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/services/metadata.ts
  - src/lib/token.ts
autonomous: true

must_haves:
  truths:
    - "Token metadata appears in Solana Explorer with name, symbol, description, image"
    - "Metadata creation uses Metaplex Token Metadata Standard"
    - "Metadata URI points to JSON file on IPFS (not directly to image)"
  artifacts:
    - path: "src/services/metadata.ts"
      provides: "Metaplex metadata creation via Umi"
      exports: ["createTokenMetadata", "MetadataConfig"]
  key_links:
    - from: "src/services/metadata.ts"
      to: "@metaplex-foundation/mpl-token-metadata"
      via: "createV1 helper"
      pattern: "createV1.*TokenStandard\\.Fungible"
    - from: "src/services/metadata.ts"
      to: "src/services/ipfs.ts"
      via: "import uploadMetadata"
      pattern: "import.*uploadMetadata.*ipfs"
---

<objective>
Create Metaplex metadata service that attaches on-chain metadata to existing SPL tokens.

Purpose: Metaplex Token Metadata is the industry standard for making tokens visible in wallets and explorers. Without metadata, tokens appear as unknown addresses. With metadata, they display name, symbol, description, and logo.

Output: Service that takes a mint address and metadata config, uploads to IPFS, and creates on-chain Metaplex metadata account.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output
@.planning/phases/02-professional-metadata/02-01-SUMMARY.md

# Research
@.planning/phases/02-professional-metadata/02-RESEARCH.md

# Existing code
@src/lib/token.ts
@src/services/ipfs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Metaplex metadata service</name>
  <files>src/services/metadata.ts</files>
  <action>
Create `src/services/metadata.ts` with:

1. **MetadataConfig interface:**
```typescript
export interface MetadataConfig {
  name: string;
  symbol: string;
  description: string;
  imagePath: string;  // Local file path to upload
}
```

2. **MetadataResult interface:**
```typescript
export interface MetadataResult {
  metadataUri: string;      // IPFS URI of metadata JSON
  imageUri: string;         // IPFS URI of image
  metadataAccount: string;  // Metadata PDA address
  signature: string;        // Transaction signature
}
```

3. **createTokenMetadata function:**
```typescript
export async function createTokenMetadata(
  connection: Connection,
  payer: Keypair,
  mint: PublicKey,
  config: MetadataConfig
): Promise<MetadataResult>
```

Implementation:
a. **Initialize Umi:**
```typescript
import { createUmi } from '@metaplex-foundation/umi-bundle-defaults';
import { mplTokenMetadata, createV1, TokenStandard } from '@metaplex-foundation/mpl-token-metadata';
import { publicKey, keypairIdentity } from '@metaplex-foundation/umi';

const umi = createUmi(connection.rpcEndpoint)
  .use(mplTokenMetadata());

// Convert web3.js Keypair to Umi keypair
const umiKeypair = umi.eddsa.createKeypairFromSecretKey(payer.secretKey);
umi.use(keypairIdentity(umiKeypair));
```

b. **Upload image to IPFS** using uploadImage from ipfs.ts

c. **Create metadata JSON** with name, symbol, description, and image URI

d. **Upload metadata JSON to IPFS** using uploadMetadata from ipfs.ts

e. **Create on-chain metadata** using Umi's createV1:
```typescript
const tx = await createV1(umi, {
  mint: publicKey(mint.toBase58()),
  authority: umi.identity,
  name: config.name,
  symbol: config.symbol,
  uri: metadataUpload.uri,
  sellerFeeBasisPoints: percentAmount(0),  // 0% for fungible tokens
  tokenStandard: TokenStandard.Fungible,
}).sendAndConfirm(umi);
```

f. **Return result** with all URIs, metadata account address (derive PDA), and signature

Handle errors with remediation hints:
- "account already in use" = metadata already exists for this mint
- "insufficient funds" = need more SOL
- IPFS errors = check PINATA_JWT

**Important:** Follow research Pattern 1 exactly. Use createV1 (not deprecated CreateMetadataAccountV3).
  </action>
  <verify>
`npm run build` succeeds
`src/services/metadata.ts` exports createTokenMetadata, MetadataConfig, MetadataResult
  </verify>
  <done>Metaplex metadata service can attach metadata to existing SPL tokens via Umi createV1</done>
</task>

<task type="auto">
  <name>Task 2: Add metadata config to TokenConfig</name>
  <files>src/lib/token.ts</files>
  <action>
Extend the existing TokenConfig interface to optionally include metadata:

```typescript
export interface TokenConfig {
  name: string;
  symbol: string;
  decimals: number;
  supply: number;
  // Optional metadata (Phase 2)
  description?: string;
  imagePath?: string;
}
```

This makes metadata optional - tokens can still be created without it (Phase 1 behavior preserved).

Do NOT modify createToken function yet - that will be done in Plan 04 when wiring CLI.
The metadata service is separate and will be called after token creation.
  </action>
  <verify>
`npm run build` succeeds
TokenConfig interface has optional description and imagePath fields
  </verify>
  <done>TokenConfig extended to support optional metadata fields while preserving Phase 1 compatibility</done>
</task>

</tasks>

<verification>
After tasks complete:
1. `npm run build` - compiles without errors
2. metadata.ts exports createTokenMetadata function
3. TokenConfig interface accepts optional description and imagePath
4. Existing create command still works (optional fields)
</verification>

<success_criteria>
- createTokenMetadata uploads image and JSON to IPFS, then creates on-chain metadata
- Uses Umi createV1 helper (not deprecated APIs)
- TokenStandard.Fungible set correctly for SPL tokens
- sellerFeeBasisPoints = 0 (not an NFT)
- Error messages include remediation hints
- TokenConfig extended without breaking existing code
</success_criteria>

<output>
After completion, create `.planning/phases/02-professional-metadata/02-02-SUMMARY.md`
</output>
