---
phase: 03-advanced-features-delivery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/burn.ts
  - src/commands/burn.ts
  - src/index.ts
  - src/utils/educational.ts
  - src/utils/display.ts
autonomous: true

must_haves:
  truths:
    - "User can run `memecoin-factory burn --mint <ADDRESS> --amount 1000` and tokens are destroyed on-chain"
    - "User sees three-level confirmation before burn executes (warning, type BURN, final confirm)"
    - "User sees on-chain supply verification after burn completes"
    - "User gets educational explanations during burn (ATA, supply reduction)"
  artifacts:
    - path: "src/lib/burn.ts"
      provides: "Burn logic: balance check, ATA resolution, burn execution, supply verification"
      exports: ["burnTokens", "getBurnInfo", "BurnResult"]
    - path: "src/commands/burn.ts"
      provides: "Burn CLI command with prompts, confirmation, display"
      exports: ["burnCommand"]
    - path: "src/index.ts"
      provides: "CLI entry point with burn command registered"
    - path: "src/utils/educational.ts"
      provides: "Burn-specific educational explanations"
      contains: "burn"
    - path: "src/utils/display.ts"
      provides: "Burn result display with supply stats"
      exports: ["displayBurnResult"]
  key_links:
    - from: "src/commands/burn.ts"
      to: "src/lib/burn.ts"
      via: "burnTokens() call"
      pattern: "burnTokens"
    - from: "src/index.ts"
      to: "src/commands/burn.ts"
      via: "burnCommand registration"
      pattern: "burnCommand"
    - from: "src/lib/burn.ts"
      to: "@solana/spl-token"
      via: "burn(), getAccount(), getAssociatedTokenAddress(), getMint()"
      pattern: "burn\\("
---

<objective>
Implement the token burn mechanism as a new CLI command, completing the token lifecycle.

Purpose: Burn is the final token operation - create, manage authorities, and now reduce supply. This demonstrates deflationary tokenomics understanding and completes the feature set for the class demo.

Output: Working `burn` command that destroys tokens with educational UX, multi-step safety confirmation, and on-chain supply verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase intelligence
@.planning/intel/summary.md

# Phase 3 research (burn patterns, confirmation UX)
@.planning/phases/03-advanced-features-delivery/03-RESEARCH.md

# Key source files to follow patterns from
@src/lib/token.ts
@src/commands/create.ts
@src/utils/educational.ts
@src/utils/display.ts
@src/utils/prompts.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create burn logic module and display utilities</name>
  <files>src/lib/burn.ts, src/utils/educational.ts, src/utils/display.ts</files>
  <action>
    Create `src/lib/burn.ts` with the burn operation logic:

    1. Export interface `BurnResult` with fields: `signature: string`, `amountBurned: number`, `supplyBefore: bigint`, `supplyAfter: bigint`, `mint: string`.

    2. Export async function `getBurnInfo(connection, mint, owner)` that:
       - Resolves the ATA using `getAssociatedTokenAddress(mint, owner.publicKey)`
       - Fetches token account info via `getAccount(connection, tokenAccount)`
       - Fetches mint info via `getMint(connection, mint)` for current supply
       - Returns `{ tokenAccount, balance: accountInfo.amount, supply: mintInfo.supply, decimals: mintInfo.decimals }`
       - Provides clear error if ATA doesn't exist ("No token account found for this mint. You may not hold any of this token.")

    3. Export async function `burnTokens(connection, payer, mint, owner, amount, decimals)` that:
       - Gets ATA via `getAssociatedTokenAddress(mint, owner.publicKey)`
       - Calculates raw amount: `BigInt(Math.round(amount * Math.pow(10, decimals)))`
       - Fetches account info and validates balance >= rawAmount with clear error message showing human-readable amounts
       - Gets supply before burn via `getMint(connection, mint)`
       - Executes `burn(connection, payer, tokenAccount, mint, owner, rawAmount)` from @solana/spl-token
       - Gets supply after burn via `getMint(connection, mint)`
       - Returns BurnResult with all fields populated

    Import from `@solana/spl-token`: `burn`, `getAccount`, `getAssociatedTokenAddress`, `getMint`.
    Import from `@solana/web3.js`: `Connection`, `Keypair`, `PublicKey`.
    Follow the error message pattern from `src/lib/token.ts` - clear messages with context.

    Update `src/utils/educational.ts`:
    - Add to EXPLANATIONS object:
      - `burnLookup`: 'Solana stores tokens in Associated Token Accounts (ATAs), not directly in wallets. We need to find your ATA for this specific token.'
      - `burnExecute`: 'Burning permanently removes tokens from circulation by sending them to a null address. The mint total supply decreases on-chain.'
      - `burnVerify`: 'We verify the burn on-chain by checking the mint supply decreased by the expected amount. Trust, but verify.'

    Update `src/utils/display.ts`:
    - Add import for `BurnResult` from `../lib/burn.js`
    - Add export function `displayBurnResult(result: BurnResult, cluster: string)` that displays:
      - Green bold header: "Tokens Burned Successfully!"
      - Burn details: amount burned, mint address
      - Supply stats: before, after, percentage of total supply burned
      - Transaction link via `getExplorerUrl(result.signature, cluster)`
      - Token link via `getExplorerAddressUrl(result.mint, cluster)`
    - Follow the exact chalk color patterns from `displayTokenResult` (gray labels, white values, cyan headers, blue links)
  </action>
  <verify>
    Run `npx tsc --noEmit` from project root - zero type errors.
    Verify `src/lib/burn.ts` exports burnTokens, getBurnInfo, BurnResult.
    Verify `src/utils/display.ts` exports displayBurnResult.
    Verify EXPLANATIONS object has burnLookup, burnExecute, burnVerify keys.
  </verify>
  <done>
    burn.ts contains burnTokens function with ATA resolution, balance validation, burn execution, and supply verification.
    display.ts contains displayBurnResult matching project styling patterns.
    educational.ts contains three burn-related explanation strings.
    TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create burn CLI command and register in entry point</name>
  <files>src/commands/burn.ts, src/index.ts</files>
  <action>
    Create `src/commands/burn.ts` following the exact pattern of `src/commands/create.ts`:

    1. Export function `burnCommand(program: Command): void` that registers a `burn` subcommand with:
       - Options: `--mint <address>` (required - mint address of token to burn), `--amount <amount>` (required - number of tokens to burn in human-readable units), `-k, --keypair <path>` (default '~/.config/solana/id.json'), `-c, --cluster <cluster>` (default 'devnet'), `-y, --yes` (skip confirmation)
       - Description: 'Burn tokens to permanently reduce supply'

    2. The action handler should:
       a. Load keypair via `loadKeypair(options.keypair)`
       b. Create connection to cluster (same pattern as create.ts)
       c. Parse mint address: `new PublicKey(options.mint)` with try/catch for invalid address error
       d. Parse amount: `Number(options.amount)` with validation (must be positive number)
       e. Call `getBurnInfo(connection, mint, keypair.publicKey)` to get current balance/supply
       f. Display burn preview:
          - Current balance (human-readable: `Number(info.balance) / Math.pow(10, info.decimals)`)
          - Amount to burn
          - Remaining after burn
          - Current total supply
       g. Three-level confirmation (unless --yes):
          - Show red bold warning: "BURN TOKENS - PERMANENT ACTION"
          - Show yellow details: amount, symbol info, supply impact
          - Show red "This action CANNOT BE UNDONE."
          - First confirm: `confirm({ message: 'I understand this is permanent and irreversible', default: false })`
          - Type-to-confirm: `input({ message: 'Type "BURN" to confirm:', validate: ... })` that requires exact match "BURN"
          - Final confirm: `confirm({ message: chalk.red('FINAL: Burn tokens?'), default: false })`
          - If any step returns false/cancelled, print "Burn cancelled." and exit
       h. Execute burn using educationalSpinner pattern:
          - First spinner: 'Locating token account...' with EXPLANATIONS.burnLookup (this is conceptual - actual burn call handles ATA internally)
          - Main spinner: 'Burning tokens...' with EXPLANATIONS.burnExecute wrapping `burnTokens()`
       i. Display result via `displayBurnResult(result, options.cluster)`
       j. Show educational verification: 'Verifying on-chain...' with EXPLANATIONS.burnVerify (verification is built into burnTokens, this is just educational display)
       k. Error handling: wrap in try/catch, use `displayError(error, 'token burn')`, process.exit(1)

    Import pattern should match create.ts exactly (same libraries, same style).

    Update `src/index.ts`:
    - Add import: `import { burnCommand } from './commands/burn.js';`
    - Add registration after createCommand: `burnCommand(program);`
    - Keep everything else unchanged
  </action>
  <verify>
    Run `npx tsc --noEmit` - zero type errors.
    Run `node --loader ts-node/esm src/index.ts --help` - shows both `create` and `burn` commands.
    Run `node --loader ts-node/esm src/index.ts burn --help` - shows --mint, --amount, --keypair, --cluster, --yes options.
  </verify>
  <done>
    `memecoin-factory burn` command is registered and shows in --help.
    burn --help displays all options with descriptions.
    Three-level confirmation prevents accidental burns.
    Educational spinners explain burn operations.
    Build succeeds with zero type errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `node --loader ts-node/esm src/index.ts --help` shows both create and burn commands
3. `node --loader ts-node/esm src/index.ts burn --help` shows correct options
4. Code follows existing patterns: chalk colors, educationalSpinner, displayError with remediation, @inquirer/prompts
5. No new npm dependencies needed (all libraries already in package.json)
</verification>

<success_criteria>
- Burn command registered and accessible via CLI
- Three-level confirmation prevents accidental token destruction
- Educational output explains ATA, burn mechanics, and verification
- Supply verification confirms on-chain state after burn
- Error messages include remediation hints (matching project pattern)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-features-delivery/03-01-SUMMARY.md`
</output>
