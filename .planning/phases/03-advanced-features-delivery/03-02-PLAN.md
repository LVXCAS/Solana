---
phase: 03-advanced-features-delivery
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - README.md
  - docs/CODE_WALKTHROUGH.md
autonomous: true

must_haves:
  truths:
    - "A new user can go from zero to creating a token on devnet in under 10 minutes by following the README"
    - "README explains all three commands (create, burn) with usage examples and expected output"
    - "Code walkthrough explains WHY security decisions were made, not just WHAT the code does"
    - "Code walkthrough covers Solana account model, SPL Token authorities, Metaplex metadata, and burn mechanics"
  artifacts:
    - path: "README.md"
      provides: "Comprehensive project documentation with quick-start, features, usage, security, troubleshooting"
      min_lines: 150
    - path: "docs/CODE_WALKTHROUGH.md"
      provides: "Learning-journey documentation explaining architecture, security decisions, and implementation patterns"
      min_lines: 200
  key_links:
    - from: "README.md"
      to: "docs/CODE_WALKTHROUGH.md"
      via: "Documentation link in README"
      pattern: "CODE_WALKTHROUGH"
    - from: "README.md"
      to: "src/commands/create.ts"
      via: "Usage examples referencing actual CLI commands"
      pattern: "memecoin-factory create"
    - from: "README.md"
      to: "src/commands/burn.ts"
      via: "Burn usage examples"
      pattern: "memecoin-factory burn"
---

<objective>
Create comprehensive project documentation: a README for quick-start and reference, and a code walkthrough for deep learning.

Purpose: Documentation is 80% of Phase 3's value for the class presentation. The README proves the project is professional and usable. The code walkthrough demonstrates deep understanding of Solana - the difference between "I followed a tutorial" and "I understand the architecture."

Output: README.md at project root + docs/CODE_WALKTHROUGH.md explaining the learning journey.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase intelligence
@.planning/intel/summary.md

# Phase 3 research (documentation patterns, README structure)
@.planning/phases/03-advanced-features-delivery/03-RESEARCH.md

# Prior plan summary (burn command exists)
@.planning/phases/03-advanced-features-delivery/03-01-SUMMARY.md

# Source files to reference in documentation
@src/lib/token.ts
@src/lib/burn.ts
@src/commands/create.ts
@src/commands/burn.ts
@src/services/authority.ts
@src/services/metadata.ts
@src/services/ipfs.ts
@src/utils/educational.ts
@src/utils/display.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comprehensive README</name>
  <files>README.md</files>
  <action>
    Create `README.md` at the project root (replace any existing README). Follow the three-tier structure from research: quick-start -> detailed usage -> deep dive links.

    Structure the README with these sections in order:

    **Header:**
    - Project name: "Memecoin Factory"
    - One-line description: "A security-first CLI tool for creating SPL tokens on Solana with automatic anti-rug protections"
    - Badge-style feature callouts (plain text, not image badges): Security-First | Metaplex Metadata | IPFS Storage | Educational UX | Token Burning

    **Quick Start (target: working in under 10 minutes):**
    - Prerequisites list: Node.js 18+, Solana CLI, funded devnet wallet
    - 4-step setup: clone, install, generate keypair (if needed), airdrop devnet SOL
    - First command: `npm run dev -- create` with brief expected output description
    - Keep this section short - get user to "wow it works" fast

    **What This Project Does:**
    - 2 paragraphs: problem (most token tutorials skip security), solution (security-first defaults)
    - Mention this was built as a learning project to understand Solana development end-to-end
    - Briefly mention the educational UX angle

    **Features:**
    - Security-First Token Creation: authorities revoked by default
    - Professional Metadata: Metaplex + IPFS integration
    - Token Burning: deflationary supply reduction
    - Educational UX: explains each operation as it runs
    - Dry-Run Mode: preview operations without spending SOL
    - Authority Dashboard: visual status of all token authorities
    - Cost Estimation: shows exact SOL costs before confirmation

    **Usage Examples (the meat of the README):**
    - Create token (interactive): `npm run dev -- create` with sample prompts/output
    - Create token (flags): `npm run dev -- create --name "My Token" --symbol "MYT" --decimals 9 --supply 1000000`
    - Create with metadata: add --description and --image flags
    - Dry-run mode: `npm run dev -- create --dry-run`
    - Burn tokens: `npm run dev -- burn --mint <ADDRESS> --amount 1000`
    - Show expected output snippets for each (abbreviated, showing key lines)

    **Security Approach:**
    - Explain the three layers: mint authority revocation, freeze authority revocation, optional metadata lock
    - Brief explanation of WHY each matters (1-2 sentences per layer)
    - Link to CODE_WALKTHROUGH.md for deeper explanation

    **Architecture Overview:**
    - Simple directory tree showing src/ structure
    - One sentence per directory explaining purpose (commands/, lib/, services/, utils/)
    - Link to CODE_WALKTHROUGH.md for detailed walkthrough

    **Configuration:**
    - Environment variables: PINATA_JWT (for IPFS), keypair path, cluster selection
    - Network switching: --cluster devnet vs mainnet-beta

    **Troubleshooting:**
    - "Insufficient funds" -> airdrop command
    - "Keypair file not found" -> keygen command
    - "Transaction timeout" -> retry, check Solana status
    - "PINATA_JWT not set" -> Pinata account setup steps
    - "Invalid mint address" -> check address format
    - Each with the exact fix command

    **Learning Outcomes:**
    - Bullet list of what building/using this teaches
    - Solana account model, SPL Token mechanics, Metaplex metadata, IPFS content addressing, transaction cost model, authority-based security

    **Technology Stack:**
    - Table: Library | Purpose | Why Chosen
    - Include: @solana/web3.js, @solana/spl-token, @metaplex-foundation/umi, pinata, commander, chalk, ora, @inquirer/prompts

    **License:**
    - MIT

    Tone: professional yet approachable. Write for a technically literate reader (classmates, instructor) who may not know Solana. Avoid jargon without explanation. Use code blocks liberally.
  </action>
  <verify>
    README.md exists at project root.
    Contains "Quick Start" section with setup commands.
    Contains usage examples for both create and burn commands.
    Contains "Security Approach" section explaining three authority layers.
    Contains "Troubleshooting" section with at least 4 common issues.
    Links to docs/CODE_WALKTHROUGH.md.
    Total length is between 150-400 lines (comprehensive but not bloated).
  </verify>
  <done>
    README.md provides complete project documentation.
    A new user can follow Quick Start to create a token in under 10 minutes.
    All CLI commands are documented with examples.
    Security approach is clearly explained.
    Troubleshooting covers common failure modes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create code walkthrough documentation</name>
  <files>docs/CODE_WALKTHROUGH.md</files>
  <action>
    Create `docs/` directory if it doesn't exist. Create `docs/CODE_WALKTHROUGH.md` as a learning-journey document.

    This is NOT an API reference. This explains WHY decisions were made, not just what the code does. Structure as a journey through the codebase.

    Structure:

    **Introduction:**
    - What this document covers and who it's for
    - How to read it: follow the token lifecycle (create -> metadata -> authority -> burn)
    - Estimated reading time: ~15 minutes

    **Chapter 1: Project Architecture**
    - Directory structure with purpose of each layer
    - Why this structure: separation of concerns (lib = logic, services = external integrations, utils = shared helpers, commands = CLI interface)
    - Data flow diagram (text-based): User Input -> Commands -> Lib/Services -> Solana Blockchain

    **Chapter 2: Token Creation Flow**
    - Walk through `src/lib/token.ts` createToken() step by step
    - Explain the Solana account model: Why createMint creates an account, not just a "token"
    - Explain rent exemption: Why Solana accounts need SOL deposits (anti-spam design)
    - Explain the minting step: Why supply is `amount * 10^decimals` (raw units vs human-readable)
    - Show the code snippet and explain the "why" for each parameter
    - Design decision: Why all operations are in one function (atomicity guarantee)

    **Chapter 3: Security by Default**
    - The philosophy: Why security is automatic, not optional
    - Walk through authority revocation code
    - Explain `setAuthority(... null)` - why null means permanent revocation
    - Three authority types and their attack vectors:
      - Mint authority: infinite supply rug pull
      - Freeze authority: honeypot attacks (freeze tokens so they can't be sold)
      - Metadata authority: identity theft (change token name to impersonate another token)
    - Design decision: Why we revoke immediately after creation, not later
    - Reference the authority dashboard display

    **Chapter 4: Metaplex Metadata Integration**
    - Why tokens need metadata (raw SPL tokens are just numbers, no name/symbol)
    - The metadata standard: Metaplex Token Metadata program
    - Walk through the two-tier storage pattern:
      1. Image uploaded to IPFS (permanent, decentralized)
      2. Metadata JSON uploaded to IPFS (references image)
      3. On-chain metadata account created (references metadata JSON URI)
    - Why IPFS instead of centralized storage (permanence, decentralization)
    - Explain the Umi framework: Why it's needed alongside @solana/web3.js (Metaplex's abstraction layer)

    **Chapter 5: Token Burning**
    - Why burn exists: deflationary tokenomics, supply management
    - Walk through the burn flow:
      1. ATA resolution: Why we need the token account, not the wallet address
      2. Balance validation: Why check before sending transaction (save fees, better UX)
      3. Burn execution: What happens on-chain (tokens sent to null, supply decremented)
      4. Supply verification: Why we verify after burn (trust but verify)
    - The confirmation UX: Why three levels for destructive actions (UX best practices)

    **Chapter 6: Educational UX Pattern**
    - The educationalSpinner pattern: Show progress AND teach simultaneously
    - Why this approach: Users learn Solana concepts while waiting for operations
    - Walk through the explain() and educationalSpinner() functions
    - How EXPLANATIONS object centralizes educational content
    - Design decision: concise explanations (1-2 sentences) to avoid wall-of-text fatigue

    **Chapter 7: Error Handling Philosophy**
    - Context-specific remediation: Every error suggests a fix
    - Walk through displayError() and its pattern matching
    - Why not generic "something went wrong" messages
    - Graceful degradation: metadata failure doesn't kill token creation

    **Conclusion: What I Learned**
    - 5-7 key insights from building this project
    - What surprised me about Solana development
    - What I'd do differently next time
    - Suggested next steps for extending the project

    Use actual code snippets from the codebase (abbreviated where needed). Every code snippet should have a "Why this matters" explanation. Tone should be conversational and educational - like explaining to a smart classmate.
  </action>
  <verify>
    docs/CODE_WALKTHROUGH.md exists.
    Contains at least 7 chapters covering the full token lifecycle.
    Contains actual code snippets from the codebase (not made-up examples).
    Each chapter has a "why" explanation, not just "what" description.
    Contains a conclusion with learning outcomes.
    Total length between 200-500 lines.
  </verify>
  <done>
    CODE_WALKTHROUGH.md is a complete learning-journey document.
    Covers architecture, token creation, security, metadata, burning, UX patterns, and error handling.
    Every section explains WHY, not just WHAT.
    Contains real code snippets from the codebase.
    Demonstrates deep understanding of Solana development.
  </done>
</task>

</tasks>

<verification>
1. README.md exists at project root with Quick Start, Features, Usage, Security, Troubleshooting sections
2. docs/CODE_WALKTHROUGH.md exists with 7+ chapters covering full token lifecycle
3. README links to CODE_WALKTHROUGH.md
4. README usage examples reference actual CLI commands (`npm run dev -- create`, `npm run dev -- burn`)
5. CODE_WALKTHROUGH contains actual code snippets from source files
6. Both documents explain "why" not just "what"
</verification>

<success_criteria>
- New user can create a token following README Quick Start in under 10 minutes
- README documents all CLI commands with examples
- Code walkthrough explains architecture decisions and security rationale
- Documentation demonstrates deep Solana understanding (not surface-level tutorial)
- Both documents are professional quality suitable for class presentation
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-features-delivery/03-02-SUMMARY.md`
</output>
